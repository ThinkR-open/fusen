# WARNING - Generated by {fusen} from /dev/flat_clean_fusen_files.Rmd: do not edit by hand

# Or you can try on the reproducible example
dummypackage <- tempfile("register")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage, {
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )
})
# Add a not registered file to the package
cat("# test R file", file = file.path(dummypackage, "R", "to_keep.R"))


test_that("register_all_to_config works", {
  expect_true(inherits(register_all_to_config, "function")) 
  
  usethis::with_project(dummypackage, {
    expect_error(
      out_path <- register_all_to_config(dummypackage), regexp = NA)
        expect_equal(out_path, file.path("dev", "config_fusen.yaml"))
        
    # What happens if everything is already registered?
        expect_message(
      out_path <- register_all_to_config(dummypackage), regexp = "There is no file to register")
            
        expect_equal(out_path, file.path("dev", "config_fusen.yaml"))

  })
})

# Test df_to_config with custom config file path ----
config_file_path <- tempfile(fileext = ".yaml")

test_that("df_to_config fails when appropriate", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    all_files <- tibble::tribble(
      ~type, ~files,
      "R", "zaza.R",
      "R", "zozo.R",
      "test", "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files, flat_file_path = "keep"),
      "df_files should contains two columns named: 'type' and 'path'"
    )

    all_files <- tibble::tribble(
      ~type, ~path,
      "R", "zaza.R",
      "R", "zozo.R",
      "test", "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files),
      "Some 'path' in df_files do not exist: row 1- R: zaza.R, row 2- R: zozo.R, row 3- test: test-zaza.R"
    )
  })
})


# Create files, even empty
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R")))

test_that("df_to_config works", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      
      # Use full path
      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R"
      )
      
      expect_message(config_file_out <- df_to_config(all_files))
    })
    
    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(names(all_keep$keep), c("path", "R", "tests", "vignettes"))
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, list())
  })
})

# Second pass
all_files <- tibble::tribble(
  ~type, ~path,
  "r", "tata.R",
  "R", "toto.R",
  "tests", "test-tata.R",
  "vignettes", "tata_vignette.Rmd"
)

file.create(file.path(dir_tmp, c("tata.R", "toto.R", "test-tata.R", "tata_vignette.Rmd")))

test_that("df_to_config works after 2nd run", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      # debugonce(df_to_config)
      expect_message(
        config_file <- df_to_config(all_files),
        regexp = "Some files group already existed and were overwritten: keep"
      ) # "keep" is default
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)

# Create files, even empty ----
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R")))
dir.create(file.path(dir_tmp, "vignettes"))
file.create(file.path(dir_tmp, "vignettes", "my-vignette.Rmd"))

test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {
      
      # Use relative path
      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R",
        "vignette", file.path("vignettes", "my-vignette.Rmd")
      )
      
      expect_message(config_file_out <- df_to_config(all_files))
    })
    
    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(names(all_keep$keep), c("path", "R", "tests", "vignettes"))
    expect_equal(all_keep$keep$path, c("keep"))
    # Relative path
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, c("vignettes/my-vignette.Rmd"))
  })
})

# Remove one file to see if it is detected
file.remove(file.path(dir_tmp, c("zaza.R")))
test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {
      
      # Use relative path
      all_files <- tibble::tribble(
        ~type, ~path,
        "R", "zaza.R",
        "R", "zozo.R",
        "test", "test-zaza.R",
        "vignette", file.path("vignettes", "my-vignette.Rmd")
      )
      
      expect_error(config_file_out <- df_to_config(all_files), regexp = "zaza.R")
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)
# rstudioapi::navigateToFile(config_file)

dummypackage <- tempfile("registered")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]

usethis::with_project(dummypackage, {
  test_that("check_not_registered_files returns message if empty", {
    expect_true(inherits(check_not_registered_files, "function"))

    # debugonce(check_not_registered_files)
    expect_message(check_not_registered_files(), "There are no files in the package")
  })

  # Inflate once
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )

  guessed_path <- guess_flat_origin(file.path(dummypackage, "R", "my_median.R"))
  # Relative path
  expect_equal(guessed_path, file.path("dev", "flat_full.Rmd"))

  guessed_path <- guess_flat_origin(file.path(dummypackage, "dev", "0-dev_history.Rmd"))
  expect_true(grepl("No existing source path found", guessed_path))

  expect_message(out_csv <- check_not_registered_files(),
    regexp = "Wrote not registered files in:  dev/config_not_registered.csv"
  )

  content_csv <- read.csv(out_csv)
  expect_true(all(names(content_csv) %in% c("type", "path", "origin")))
  expect_equal(content_csv[["type"]], c("R", "R", "test", "test", "vignette"))
  # Relative path
  expect_equal(content_csv[["path"]], 
               c("R/my_median.R",
                 "R/my_other_median.R",
                 "tests/testthat/test-my_median.R", 
                 "tests/testthat/test-my_other_median.R",
                 "vignettes/get-started.Rmd"
               ))

  # Include it in df_to_config()
  out_config <- df_to_config(df_files = out_csv)
  out_config_content <- yaml::read_yaml(out_config)
  expect_true(names(out_config_content) == "flat_full.Rmd")
  expect_equal(
    names(out_config_content[["flat_full.Rmd"]]),
    c("path", "R", "tests", "vignettes")
  )
  expect_equal(out_config_content[["flat_full.Rmd"]][["R"]],
               c("R/my_median.R", "R/my_other_median.R"))
  expect_equal(out_config_content[["flat_full.Rmd"]][["tests"]],
               c("tests/testthat/test-my_median.R", "tests/testthat/test-my_other_median.R"))
  expect_equal(out_config_content[["flat_full.Rmd"]][["vignettes"]],
               c("vignettes/get-started.Rmd"))
  # rstudioapi::navigateToFile(out_config)
  
  # Test add a R file manually and include in "keep" after `check_not_registered_files()`
  cat("# test R file", file = file.path(dummypackage, "R", "to_keep.R"))

  expect_message(out_csv <- check_not_registered_files(), "Wrote not registered files")
  content_csv <- read.csv(out_csv)
  expect_true(
    grepl(
      "No existing source path found",
      content_csv[grepl("to_keep.R", content_csv[, "path"]), "origin"]
    )
  )

  # Add in the yaml file with `df_to_config()`
  keep_to_add_to_config <- content_csv[grepl("to_keep.R", content_csv[, "path"]), ]
  keep_to_add_to_config$origin <- "keep"

  out_config <- df_to_config(keep_to_add_to_config)
  # rstudioapi::navigateToFile(out_config)
  out_config_content <- yaml::read_yaml(out_config)
  expect_equal(out_config_content$keep$R, "R/to_keep.R")

  expect_message(
    out_csv <- check_not_registered_files(),
    "There are no unregistered files"
  )
  expect_true(is.null(out_csv))

  # Add  same file in the yaml file with `df_to_config()` using different origin (existing one, but duplicate R file)
  keep_to_add_to_config$origin <- "dev/flat_full.Rmd"

  expect_error(
    df_to_config(keep_to_add_to_config),
    "Some paths would appear multiple times in the future config file."
  )

  # Add  same file in the yaml file with `df_to_config()` using different origin (not existing)
  keep_to_add_to_config$origin <- "dev/flat_dont_exists.Rmd"

  expect_error(
    df_to_config(keep_to_add_to_config),
    "Some 'origin' in df_files do not exist: row 1: dev/flat_dont_exists.Rmd"
  )
})


# Test full ----
# Change options(fusen.config_file = "dev/config_fusen.yaml")
dummypackage <- tempfile("clean")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]

# Detect all files created ----
usethis::with_project(dummypackage, {
  # Create empty config file

  # Inflate once
  suppressMessages(
    inflate(
      pkg = dummypackage, flat_file = flat_file,
      vignette_name = "Get started", check = FALSE,
      open_vignette = FALSE
    )
  )

  # debugonce(inflate)
})
