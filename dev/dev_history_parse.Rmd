---
title: "dev_history.Rmd for working package"
author: "Sébastien Rochette"
date: "23/01/2021"
output: html_document
---

```{r development, include=FALSE}
library(testthat)
```

# Parse and split a Rmarkdown file, and transform as tibble

```{r function}
#' Split Rmarkdown file
#'
#' @param file Path to Rmarkdown file
#' @importFrom utils head tail
#'
#' @export
#'
#' @return A tibble with a line for each Rmd part
split_rmd <- function(file) {
  x <- xfun::read_utf8(file)

  target_labels <- c("description", "development", "function", "example", "test")

  groups <- group_rmd(file)
  first_of_group <- c(TRUE, (head(groups, -1)) != tail(groups, -1))
  count_groups <- cumsum(first_of_group)

  extract_labels <- function(x, type, lines, target_labels) {
    if (type[[x]] != "rmd_chunk") {
      return(NA_character_)
    } else {
      stringi::stri_extract_first_regex(lines[[x]][1], paste(target_labels, collapse = "|"))
    }
  }
  extract_title <- function(x, type, lines) {
    if (type[[x]] != "rmd_heading") {
      return(NA_character_)
    } else {
      gsub("^#+\\s+", "", lines[[x]])
    }
  }
  extract_code <- function(x, type, lines) {
    if (type[[x]] != "rmd_chunk") {
      return(NA_character_)
    } else {
      lines[[x]][-c(1, length(lines[[x]]))]
    }
  }

  parsed <- tibble::tibble(
    groups = groups[first_of_group],
    type = stringi::stri_extract_first_regex(groups, "(\\w+)"),
    lines = split(x, count_groups),
    labels = unlist(
      lapply(seq_along(type), extract_labels,
        type = type, lines = lines, target_labels = target_labels
      )
    ),
    title = unlist(lapply(seq_along(type), extract_title,
      type = type, lines = lines
    )),
    section = c(NA_character_, title[!is.na(title)])[1 + cumsum(!is.na(title))],
    code = lapply(seq_along(type), extract_code,
      type = type, lines = lines
    )
  )
  parsed
}

#' Combine a parsed tbl Rmarkdown file into a new Rmd file
combine_parsed <- function(parsed_tbl) {
  # equivalent of 'parsermd::as_document()'
  # Get all code to keep, and combine into a file
}

#' Groupe parts of Rmarkdown file
#'
#' @param file path to Rmarkdown file
#'
#' @importFrom utils head tail
#' @export
#'
#' @return Character vector of groups of lines
#'
#' @examples
#' file <- system.file("dev-template-tests.Rmd", package = "fusen")
#' group_rmd(file)
group_rmd <- function(file) {
  x <- readLines(file)
  # x <- xfun::read_utf8(file)

  # Info
  x_info <- rep(NA_character_, length(x))
  x_comments <- rep(NA_character_, length(x))

  # Yaml
  if (!grepl("^---$", x[1])) {stop("File parsed needs to have a yaml header starting from line 1 with: ---")}
  yaml_begin <- 1
  yaml_end <- which(grepl("^---", x))[2]
  x_info[yaml_begin:yaml_end] <- "rmd_yaml_list"

  # Chunks
  chunk.begin <- knitr::all_patterns$md$chunk.begin
  chunk.end <- knitr::all_patterns$md$chunk.end
  blks <- grepl(chunk.begin, x)
  blks_ends <- grepl(chunk.end, x)
  # get
  txts <- utils::getFromNamespace("filter_chunk_end", "knitr")(blks, grepl(chunk.end, x))
  if (length(blks) != length(txts)) {
    stop("You may have let some not closed chunks")
  }
  chunks_lines_list <- lapply(
    seq_along(which(blks)),
    function(x) {
      which(blks)[x]:which(txts)[x]
    }
  )
  count_chunks <- seq_along(chunks_lines_list)
  count_chunks <- formatC(count_chunks, flag = "0", width = max(nchar(count_chunks)))
  chunks_lines_nb <- unlist(lapply(
    seq_along(chunks_lines_list),
    function(x) {
      rep(
        paste0("rmd_chunk-", count_chunks[x]),
        length(chunks_lines_list[[x]])
      )
    }
  ))
  chunks_lines_vec <- unlist(chunks_lines_list)
  x_info[chunks_lines_vec] <- chunks_lines_nb

  # Comments
  # TODO : See how to take into account comments around titles ?
  # We need to keep title to separate functions families, but
  # text needs to be identified as comment to be removed in vignettes
  # Probably, the function needs to output comments as another output
  comment.begin <- "^<!--"
  comment.end <- "-->"
  starts <- which(grepl(comment.begin, x))
  starts <- starts[!starts %in% c(yaml_begin:yaml_end, chunks_lines_vec)]
  ends <- which(grepl(comment.end, x))
  ends <- ends[!ends %in% c(yaml_begin:yaml_end, chunks_lines_vec)]
  if (length(starts) != length(ends)) {
    stop("You may have let some not closed comments tags like <!-- or --> in your text")
  }
  comments_lines_list <- lapply(
    seq_along(starts),
    function(x) {
      starts[x]:ends[x]
    }
  )
  count_comments <- seq_along(comments_lines_list)
  count_comments <- formatC(count_comments, flag = "0", width = max(nchar(count_comments)))
  comments_lines_nb <- unlist(lapply(
    seq_along(comments_lines_list),
    function(x) {
      rep(
        paste0("rmd_comment-", count_comments[x]),
        length(comments_lines_list[[x]])
      )
    }
  ))
  comments_lines_vec <- unlist(comments_lines_list)
  x_comments[comments_lines_vec] <- comments_lines_nb


  # hashtags
  hashtag <- which(grepl("^#", x))
  titles <- hashtag[!hashtag %in%
    c(yaml_begin:yaml_end, chunks_lines_vec, comments_lines_vec)]
  count_titles <- seq_along(titles)
  count_titles <- formatC(count_titles, flag = "0", width = max(nchar(count_titles)))
  x_info[titles] <- paste0("rmd_heading-", count_titles)

  # text
  all_text <- which(is.na(x_info))
  # Prev is text
  count_text <- cumsum(c(TRUE, (head(all_text, -1) + 1) != tail(all_text, -1)))
  count_text <- formatC(count_text, flag = "0", width = max(nchar(count_text)))
  texts <- paste0("rmd_markdown-", count_text)
  x_info[all_text] <- texts

  # Return groups
  res <- list(info = x_info,
       comments = x_comments)
  return(res)
}

get_rmd_parts <- function(file) {
  
  rmd_lines <- readLines(file)
  # Get yaml header
  if (!grepl("^---$", rmd_lines[1])) {stop("Flat file parsed needs to have a yaml header starting from line 1 with: ---")}
  yaml_begin <- 1
  yaml_end <- which(grepl("^---", rmd_lines))[2]
  yaml_content <- yaml::yaml.load(rmd_lines[yaml_begin:yaml_end])
  yaml_tbl <- tibble(
    type = "yaml",
    label = NA,
    params = list(yaml_content),
    text = NA,
    code = NA,
    heading = NA
  )

  # Get the rest of the document without yaml
  rmd_lines_no_yaml <- rmd_lines[-c(yaml_begin:yaml_end)]
  # Use hidden functions of {knitr}
  # Code extracted will be stored in a new environment with `knitr:::split_file()`
  # Using `knitr::knit_code$restore()` makes sure there is no current Rmd to be splitted
  # Is it compatible with the function beeing included in a Rmd file ? We'll see.
  knitr::knit_code$restore()
  options(knitr.duplicate.label = "allow")
  on.exit(options(knitr.duplicate.label = NULL))
  on.exit(knitr::knit_code$restore())
  
  # Split files
  out <- knitr:::split_file(
    rmd_lines_no_yaml,
    patterns = knitr:::all_patterns$md,
    set.preamble = TRUE
  )
  out
  # out[[1]]
  # out[[2]]
  # knitr::knit_code$get('bar')
  # chunk_labels <- sapply(out[sapply(out, class) == "block"], function(x) x$params$label)
  # lapply(chunk_labels, knitr::knit_code$get)
  # knitr::knit_code$get('development')
  # knitr::knit_code$get('unnamed-chunk-19')

  res <- tibble(
    type = sapply(out, class),
    label = sapply(out, function(x)
      ifelse(
        !is.null(x$params$label), x$params$label, NA
      )),
    params = lapply(out, function(x)
      if (!is.null(x$params) && 
          (is.null(x$params$engine) || x$params$engine == "r")) {
        # if chunk is not 'r' chunk, it must be accounted as text
        x$params
      } else {
        NA
      }),
    text = lapply(out, function(x)
      if (class(x) == "inline") {
        unlist(strsplit(x$input, "\n"))
      } else if (!is.null(x$params) && 
          !is.null(x$params$engine) && x$params$engine != "r") {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      }),
    code = lapply(out, function(x)
      if (!is.null(x$params) && 
          !is.null(x$params$engine) && x$params$engine != "r") {
        NA
      } else if (class(x) == "block") {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      })
  )
      
  # TODO - Extract headers
  # split_headers_in_text
  split_headers_from_text <- function(the_text) {
    new_group <- rep(FALSE, length(the_text))
    which_header <- grep("^#", the_text)
    if (length(which_header) != 0) {
      new_group[which_header] <- TRUE
      # Change group just after header
      which_header_plus <- 1 + which_header[(which_header + 1) <= length(new_group)]
      if (length(which_header_plus) != 0) {
        new_group[which_header_plus] <- TRUE
      }
      groups <- cumsum(new_group)
      groups[which_header] <- paste0(groups[which_header], "-heading")
      
      split_text <- split(the_text, groups)
    } else {
      split_text <- list(the_text)
    }
    return(split_text)
  }

  res_split <- res
  res_split$text <- lapply(res_split$text, split_headers_from_text)
  res_split <- tidyr::unnest(res_split, cols = text)
  # Get headings
  res_split$heading <- sapply(
    1:nrow(res_split),
    function(x) 
      if (grepl("heading", names(res_split$text)[x])) {
        gsub("^#*\\s*", "", res_split$text[x])
      } else {NA}
  )

  
  # Put back yaml in 'res'
  res_full <- rbind(yaml_tbl, res_split)

  
  # res_full[["code"]][[2]]
  # res_full[["code"]][[4]]
  # res_full[["text"]][[4]]
  # res_full[21,]$params
  # res[20,]$text
  # as.character(res[["code"]][[20]])
  
  
  # Reste à diviser les 'inline' pour détecter les titres
  # Allez voir dans group_rmd()
  
  return(res_full)
}
```

```{r examples}
file <- system.file("tests-templates/dev-template-parsing.Rmd", package = "fusen")
# Attribute group to each line
group_rmd(file)
# Split Rmd by group into tibble
split_rmd(file)
```

```{r dev, eval=FALSE}
# What we expect from split_rmd()
file <- system.file("tests-templates/dev-template-parsing.Rmd", package = "fusen")
full_parsed_list <- parsermd::parse_rmd(file)
full_parsermd_tbl <- parsermd::as_tibble(full_parsed_list)
saveRDS(full_parsermd_tbl, file = here::here("data-raw/full_parsermd_tbl.rds"))
dput(full_parsermd_tbl, file = here::here("data-raw/full_parsermd_tbl.dput"))
class(full_parsermd_tbl$ast)
# [1] "rmd_ast" "list"  
full_parsermd_tbl$type[[1]]
# [1] "rmd_yaml_list"
full_parsermd_tbl$ast[[1]]
# $title
# [1] "dev_history.Rmd for working package"
# 
# $output
# [1] "html_document"
# 
# $author
# [1] "statnmap"
# 
# $editor_options
# $editor_options$chunk_output_type
# [1] "console"
# 
# 
# attr(,"class")
# [1] "rmd_yaml_list"
names(full_parsermd_tbl$ast)
# NULL
slotNames(full_parsermd_tbl$ast)
# character(0)
full_parsermd_tbl$ast[[2]]
# $engine
# [1] "r"
# 
# $name
# [1] "development"
# 
# $options
# $options$include
# [1] "FALSE"
# 
# 
# $code
# [1] "library(testthat)"
# 
# $indent
# [1] ""
# 
# attr(,"class")
# [1] "rmd_chunk"
full_parsermd_tbl$ast[[3]]
# [1] "<!--"
# attr(,"class")
# [1] "rmd_markdown"
full_parsermd_tbl$sec_h1[[4]]
full_parsermd_tbl$sec_h2[[4]]
full_parsermd_tbl$ast[[4]]
# $name
# [1] "Description of your package"
# 
# $level
# [1] 1
# 
# attr(,"class")
# [1] "rmd_heading"
```


```{r tests}
# file <- system.file("tests-templates/dev-template-parsing.Rmd", package = "fusen")
# debugonce(group_rmd)
# debugonce(split_rmd)
# tbl_rmd <- split_rmd(file)

# => Try with {knitr} hidden functions
file <- system.file("tests-templates/dev-template-parsing.Rmd", package = "fusen")
debugonce(get_rmd_parts)
tbl_rmd <- get_rmd_parts(file)


# TDD
# get_rmd_parts works as expected ----
test_that("get_rmd_parts gets yaml header data", {
  expect_equal(sum(tbl_rmd[["type"]] == "yaml"), 1)
  w_yaml <- which(tbl_rmd[["type"]] == "yaml")
  expect_equal(tbl_rmd[["params"]][[w_yaml]]$title, "dev_history.Rmd for working package")
  expect_equal(tbl_rmd[["params"]][[w_yaml]]$author, "statnmap")
  expect_equal(tbl_rmd[["params"]][[w_yaml]]$date, "2023-10-12")
  # expect_s3_class(tbl_rmd[["params"]][[w_yaml]], "rmd_yaml_list")
})

test_that("get_rmd_parts gets H1 titles in markdown part only", {
  expect_equal(sum(tbl_rmd[["type"]] == "rmd_heading"), 6)
  expect_equal(sum(!is.na(tbl_rmd[["sec_h1"]])), 5)
  expect_equal(tbl_rmd[["sec_h1"]][!is.na(tbl_rmd[["sec_h1"]])],
               c("Description of your package", 
                 "Read data",
                 "Calculate the median of a vector",
                 "Calculate the mean of a vector",
                 "Inflate your package"))
  expect_s3_class(tbl_rmd_yaml[["ast"]], "rmd_heading")
})

test_that("split_rmd gets H2 titles in markdown part only", {
  expect_equal(sum(tbl_rmd[["type"]] == "rmd_heading"), 6)
  expect_equal(sum(!is.na(tbl_rmd[["sec_h2"]])), 1)
  expect_equal(tbl_rmd[["sec_h1"]][!is.na(tbl_rmd[["sec_h2"]])],
               c("Use sub-functions in the same chunk"))
  expect_s3_class(tbl_rmd_yaml[["ast"]], "rmd_heading")
})


# Sub tests ----
groups <- group_rmd(file)
test_that("group_rmd works properly", {
  expect_true(all(groups[1:8] == "rmd_yaml_list"))
  expect_true(all(groups[10:12] == "rmd_chunk-01"))
  expect_true(all(groups[14:19] == "rmd_comment-1"))
  expect_true(all(groups[21:35] == "rmd_chunk-02"))
  expect_true(all(groups[37] == "rmd_heading-1"))
})

file <- system.file("dev-template-test-parse-nothing.Rmd", package = "fusen")
groups <- group_rmd(file)
test_that("group_rmd does not fail", {
  expect_true(all(groups[1:8] == "rmd_yaml_list"))
})

file <- system.file("dev-template-tests.Rmd", package = "fusen")
tbl_rmd <- split_rmd(file)
test_that("split_rmd works", {
  expect_true(nrow(tbl_rmd) == 47)
  expect_true(ncol(tbl_rmd) == 7)
  expect_true(all(tbl_rmd[["lines"]][[3]] ==
    c("```{r development, include=FALSE}", "library(testthat)", "```")))
  expect_true(tbl_rmd[["type"]][3] == "rmd_chunk")
  expect_true(tbl_rmd[["type"]][9] == "rmd_heading")
  expect_true(tbl_rmd[["labels"]][3] == "development")
  expect_true(tbl_rmd[["title"]][9] == "Calculate the median of a vector")
  expect_true(tbl_rmd[["section"]][10] == "Calculate the median of a vector")
  expect_true(tbl_rmd[["code"]][[3]] == "library(testthat)")
})
```

```{r development-2, eval=FALSE}
fusen::inflate(flat_file = file.path("dev", "dev_history_parse.Rmd"), vignette_name = NA, check = FALSE)
```
