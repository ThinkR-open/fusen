---
title: "dev_history.Rmd for working package"
author: "SÃ©bastien Rochette"
date: "23/01/2021"
output: html_document
---

```{r development, include=FALSE}
library(testthat)
```

# Parse and split a Rmd / Qmd file, and transform as tibble

This is the core of {fusen}. Where everything starts.  
{fusen} reads your flat file to detect what is a yaml header, 
what is a code chunk and its options, what is a text part.  
Function `get_rmd_parts()` returns a tibble with all these parts.

You're not supposed to use this function directly when working with {fusen}.
However, since {parsermd} is not maintained anymore, you may be interested in
having access to these core functions.

```{r function}
#' Group lines of a Rmd or Qmd file by types in a tibble
#'
#' @param file A Rmd or Qmd file path
#' @return A tibble with 6 columns:
#' - `type`: type of the part (yaml, heading, inline, block)
#' - `label`: label of the part (if any)
#' - `params`: parameters of the part (if any)
#' - `text`: text of the part (if any)
#' - `code`: code of the part (if any)
#' - `heading`: heading of the part (if any)
#'
#' @export
get_rmd_parts <- function(file) {
  rmd_lines <- readLines(file)
  # Get yaml header
  if (!grepl("^---$", rmd_lines[1])) {
    stop("Flat file parsed needs to have a yaml header starting from line 1 with: ---")
  }
  yaml_begin <- 1
  yaml_end <- which(grepl("^---", rmd_lines))[2]
  yaml_content <- yaml::yaml.load(rmd_lines[yaml_begin:yaml_end])
  yaml_tbl <- tibble(
    type = "yaml",
    label = NA,
    params = list(yaml_content),
    text = NA,
    code = NA,
    heading = NA
  )

  # Get the rest of the document without yaml
  rmd_lines_no_yaml <- rmd_lines[-c(yaml_begin:yaml_end)]
  # Use hidden functions of {knitr}
  # Code extracted will be stored in a new environment
  # with `knitr:::split_file()`
  # Using `knitr::knit_code$restore()` makes sure there is no current Rmd to be
  # splitted
  # Is it compatible with the function beeing included in a Rmd file ?
  # We'll see.
  getFromNamespace("knit_log", "knitr")$restore()
  knitr::knit_code$restore()
  getFromNamespace("chunk_counter", "knitr")(reset = TRUE)
  options(knitr.duplicate.label = "allow")
  # Restore after splitting
  on.exit(options(knitr.duplicate.label = NULL))
  # restore unnamed-chunk counter
  on.exit(getFromNamespace("chunk_counter", "knitr")(reset = TRUE))
  on.exit(knitr::knit_code$restore())
  on.exit(getFromNamespace("knit_log", "knitr")$restore())


  # Split files
  out <- getFromNamespace("split_file", "knitr")(
    rmd_lines_no_yaml,
    patterns = getFromNamespace("all_patterns", "knitr")$md,
    set.preamble = TRUE
  )

  res <- tibble(
    type = sapply(out, class),
    label = sapply(out, function(x) {
      ifelse(
        !is.null(x$params$label), x$params$label, NA
      )
    }),
    params = lapply(out, function(x) {
      if (!is.null(x$params) &&
        (is.null(x$params$engine) || x$params$engine == "r")) {
        # if chunk is not 'r' chunk, it must be accounted as text
        x$params
      } else {
        NA
      }
    }),
    text = lapply(out, function(x) {
      if (inherits(x, "inline")) {
        unlist(strsplit(x$input, "\n"))
      } else if (
        !is.null(x$params) &&
          !is.null(x$params$engine) &&
          x$params$engine != "r"
      ) {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      }
    }),
    code = lapply(out, function(x) {
      if (
        !is.null(x$params) &&
          !is.null(x$params$engine) &&
          x$params$engine != "r"
      ) {
        NA
      } else if (inherits(x, "block")) {
        knitr::knit_code$get(x$params$label)
      } else {
        NA
      }
    })
  )

  # TODO - Extract headers
  # split_headers_in_text
  split_headers_from_text <- function(the_text) {
    new_group <- rep(FALSE, length(the_text))
    which_header <- grep("^#", the_text)
    if (length(which_header) != 0) {
      new_group[which_header] <- TRUE
      # Change group just after header
      which_header_plus <- 1 + which_header[
        (which_header + 1) <= length(new_group)
      ]
      if (length(which_header_plus) != 0) {
        new_group[which_header_plus] <- TRUE
      }
      groups <- cumsum(new_group)
      groups[which_header] <- paste0(groups[which_header], "-heading")

      split_text <- split(the_text, groups)
    } else {
      split_text <- list(the_text)
    }
    return(split_text)
  }

  res_split <- res
  res_split$text <- lapply(res_split$text, split_headers_from_text)
  res_split <- tidyr::unnest(res_split, cols = text)
  # Get headings
  res_split$heading <- sapply(
    seq_len(nrow(res_split)),
    function(x) {
      if (grepl("heading", names(res_split$text)[x])) {
        gsub("^#*\\s*", "", res_split$text[x])
      } else {
        NA
      }
    }
  )

  res_split$type[!is.na(res_split$heading)] <- "heading"

  # Put back yaml in 'res'
  res_full <- rbind(yaml_tbl, res_split)

  return(res_full)
}

#' Prepare all content from parsedtbl to be combined into a Rmd file
#' @param parsed_tbl A tibble with 6 columns as issued by `get_rmd_parts()`
#' @return A tibble with a new column `content` containing the content
#'  for the future rmd file
#' @noRd
get_content_parsedtbl <- function(parsed_tbl) {
  message(c(
    "TODO - This function is not yet implemented",
    "and will be added in get_rmd_parts() directly"
  ))
}

#' Combine a parsed tbl Rmarkdown file into a new Rmd file
#' @param parsed_tbl A tibble with 6 columns as issued by `get_rmd_parts()`
#' @return A Rmd file
#' @export
combine_parsed <- function(parsed_tbl) {
  # equivalent of 'parsermd::as_document()'
  # Get all code to keep, and combine into a file
  print("TODO - This function is not yet implemented")
}
```

```{r examples}
file <- system.file("tests-templates/dev-template-parsing.Rmd",
  package = "fusen"
)
get_rmd_parts(file)
```

```{r dev, eval=FALSE}
# What we expect from split_rmd()
file <- system.file("tests-templates/dev-template-parsing.Rmd", package = "fusen")
full_parsed_list <- parsermd::parse_rmd(file)
full_parsermd_tbl <- parsermd::as_tibble(full_parsed_list)
saveRDS(full_parsermd_tbl, file = here::here("data-raw/full_parsermd_tbl.rds"))
dput(full_parsermd_tbl, file = here::here("data-raw/full_parsermd_tbl.dput"))
class(full_parsermd_tbl$ast)
# [1] "rmd_ast" "list"
full_parsermd_tbl$type[[1]]
# [1] "rmd_yaml_list"
full_parsermd_tbl$ast[[1]]
# $title
# [1] "dev_history.Rmd for working package"
#
# $output
# [1] "html_document"
#
# $author
# [1] "statnmap"
#
# $editor_options
# $editor_options$chunk_output_type
# [1] "console"
#
#
# attr(,"class")
# [1] "rmd_yaml_list"
names(full_parsermd_tbl$ast)
# NULL
slotNames(full_parsermd_tbl$ast)
# character(0)
full_parsermd_tbl$ast[[2]]
# $engine
# [1] "r"
#
# $name
# [1] "development"
#
# $options
# $options$include
# [1] "FALSE"
#
#
# $code
# [1] "library(testthat)"
#
# $indent
# [1] ""
#
# attr(,"class")
# [1] "rmd_chunk"
full_parsermd_tbl$ast[[3]]
# [1] "<!--"
# attr(,"class")
# [1] "rmd_markdown"
full_parsermd_tbl$sec_h1[[4]]
full_parsermd_tbl$sec_h2[[4]]
full_parsermd_tbl$ast[[4]]
# $name
# [1] "Description of your package"
#
# $level
# [1] 1
#
# attr(,"class")
# [1] "rmd_heading"
```


```{r tests}
file <- system.file("tests-templates/dev-template-parsing.Rmd",
  package = "fusen"
)
# debugonce(get_rmd_parts)
tbl_rmd <- get_rmd_parts(file)

# get_rmd_parts works as expected ----
test_that("get_rmd_parts gets yaml header data", {
  expect_equal(sum(tbl_rmd[["type"]] == "yaml"), 1)
  w_yaml <- which(tbl_rmd[["type"]] == "yaml")
  expect_equal(
    tbl_rmd[["params"]][[w_yaml]]$title,
    "dev_history.Rmd for working package"
  )
  expect_equal(tbl_rmd[["params"]][[w_yaml]]$author, "statnmap")
  expect_equal(tbl_rmd[["params"]][[w_yaml]]$date, "2023-10-12")
})

# Find all headings
headings <- c(
  "Description of your package",
  "Read data",
  "Calculate the median of a vector",
  "Calculate the mean of a vector",
  "Use sub-functions in the same chunk",
  "Inflate your package"
)

test_that("get_rmd_parts gets titles in markdown part only", {
  expect_equal(sum(tbl_rmd[["type"]] == "heading"), 6)
  expect_equal(tbl_rmd[["heading"]][!is.na(tbl_rmd[["heading"]])], headings)
})

test_that("get_rmd_parts gets text parts without titles", {
  expect_equal(sum(tbl_rmd[["type"]] == "inline"), 16)
  expect_equal(
    sum(tbl_rmd[["type"]] == "inline"),
    length(tbl_rmd[["text"]][!is.na(tbl_rmd[["text"]])]) -
      sum(tbl_rmd[["type"]] == "heading")
  )
  expect_length(tbl_rmd[tbl_rmd[["type"]] == "inline", ][["text"]][[1]], 0)
  expect_equal(
    tbl_rmd[tbl_rmd[["type"]] == "inline", ][["text"]][[3]],
    c("", "This will fill the description of your package.", "-->")
  )
  # Verify there is no title in the lists
  expect_false(any(headings %in%
    unlist(tbl_rmd[tbl_rmd[["type"]] == "inline", ][["text"]])))
})

test_that("get_rmd_parts gets R-only chunks with label and options", {
  expect_equal(sum(tbl_rmd[["type"]] == "block"), 12)
  # labels
  expect_equal(
    tbl_rmd[["label"]][tbl_rmd[["type"]] == "block"],
    c(
      "development", "description", "development-2",
      "function", "examples", "tests",
      "function-1", "examples-1", "tests-1",
      "development-1", "unnamed-chunk-1", "unnamed-chunk-2"
    )
  )
  # options
  expect_equal(
    tbl_rmd[["params"]][tbl_rmd[["type"]] == "block"][[1]],
    list(label = "development", include = FALSE)
  )
  expect_equal(
    tbl_rmd[["params"]][tbl_rmd[["type"]] == "block"][[4]],
    list(label = "function")
  )
  # qmd-like options format
  expect_equal(
    tbl_rmd[["params"]][tbl_rmd[["type"]] == "block"][[7]],
    list(label = "function-1", filename = "the_median_file")
  )
})

test_that("get_rmd_parts - chunk code extracted contains R code only", {
  expect_equal(
    as.character(tbl_rmd[["code"]][tbl_rmd[["type"]] == "block"][[5]]),
    c("my_median(1:12)")
  )
  # No remaining chunk params in the code extracted
  expect_equal(
    as.character(tbl_rmd[["code"]][tbl_rmd[["type"]] == "block"][[7]])[1],
    c("#' My Other median")
  )
})

test_that(
  "get_rmd_parts gets does not increment unnamed-chunks id when run a 2nd time",
  {
    tbl_rmd <- get_rmd_parts(file)
    tbl_rmd <- get_rmd_parts(file) # 2nd time
    expect_equal(sum(tbl_rmd[["type"]] == "block"), 12)
    expect_equal(
      tbl_rmd[["label"]][tbl_rmd[["type"]] == "block"],
      c(
        "development", "description", "development-2",
        "function", "examples", "tests",
        "function-1", "examples-1", "tests-1",
        "development-1", "unnamed-chunk-1", "unnamed-chunk-2"
      )
    )
  }
)
```

```{r development-2, eval=FALSE}
fusen::inflate(
  flat_file = file.path("dev", "dev_history_parse.Rmd"),
  vignette_name = c(
    "Parse a Rmd or Qmd file into a tibble and vice-versa" =
      "z-Parse a Rmd or Qmd file into a tibble and vice-versa"
  ),
  check = FALSE
)
```
