---
title: "flat_df_to_config.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
inflate_state: active
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

## {fusen} registers all files of your package

From {fusen} >=0.5, a file named "dev/config_fusen.yaml" (by default) registers all files created from a specific "flat" file as soon as you inflate it.
This helps you keep track on the link between flat files and all R, tests and vignettes files created in your package. 

This configuration file also register all files not created from a flat file. This helps you keep your package clean.

<!--
To make this work properly, you will have to register all files that were not created from a flat file. `add_files_to_config()` will help you do so (See below: "Register some specific files, even with regex").  
-->

To know if you have some special steps to realize with this version of {fusen}, run:

```{r, eval=FALSE}
fusen::inflate_all_no_check()
```

Messages of this function will guide you through the transition if you used a too old version of {fusen}.  

Chances are that you will need to:  

1. Inflate each flat file of your project one by one (at least once) with this version of {fusen}
2. Run `fusen::check_not_registered_files()`
3. Check the content of "dev/config_not_registered.csv" if there are unregistered files.
4. Clean up your package of useless unregistered files if required.
4. Register all remaining unregistered files with `fusen::register_all_to_config()`

Try again `fusen::inflate_all_no_check()` or `fusen::inflate_all()` and that should be good now.  
_Read `vignette("inflate-all-your-flat-files", package = "fusen")` to know more about `inflate_all()`._


<!--
### Register some specific files, even with regex

TODO?

You may not want to register each new file that does not come during an inflate process. For instance, with {golem}, there are module (`^mod_*`) files, which need to be protected. You can add this regular expression directly in the yaml file with `add_files_to_config(c("R" = "^mod_*"))` 
--> 

## What is the configuration file?

The configuration file is stored as "dev/config_fusen.yaml".  
This lists all flat files that were inflated, along with the lists of all files created during inflate and the parameters used to inflate.  
This also list all other files, not created with the flat files, under a section named "keep". 

For instance, a part of the configuration file of package {fusen} looks like:

```yaml
flat_addins.Rmd:
  path: dev/flat_addins.Rmd
  state: active
  R: R/build_fusen_chunks.R
  tests: tests/testthat/test-build_fusen_chunks.R
  vignettes: []
  inflate:
    flat_file: dev/flat_addins.Rmd
    vignette_name: .na
    open_vignette: true
    check: false
    document: true
    overwrite: ask
keep:
  path: keep
  R:
  - R/addins.R
  - R/create_fusen_rsproject.R
  - R/fusen-package.R
  - R/globals.R
  - R/inflate-utils.R
  - R/load_flat_functions.R
  - R/utils-pipe.R
  tests:
  - tests/testthat/test-create_fusen_rsproject.R
  - tests/testthat/test-inflate_qmd.R
  - tests/testthat/test-inflate_utils.R
  - tests/testthat/test-load_flat_functions.R
  - tests/testthat/test-skeleton.R
  vignettes: vignettes/tips-and-tricks.Rmd
```


## What about unregistered files?

Imagine you inflated some function named `my_fun()`, and then you decide to change the name of the function to `my_new_fun()`. After inflate, there will be two files "R/myfun.R" and "R/my_new_fun.R" in your package. However, "R/myfun.R" should be deleted because this function should not exist anymore.  

If you are unsure about which files should still be there or not, you can run `fusen::check_not_registered_files()`. In this case, "R/myfun.R" will appear in the csv file created in "dev/config_not_registered.csv", with a message like "Possibly deprecated file". 

You now have the possibility to detect deprecated files of your project.  
Run `fusen::check_not_registered_files()` as often as you need if you want to clean your project.
_Note that this function is included in `fusen::inflate_all()` and `fusen::inflate_all_no_check()`, which let you the opportunity to clean your project regularly._

To be able to detect deprecated files, all legitimate files need to be registered. Even the ones that you created manually. In this case, they will be listed under the `"keep"` section. {fusen} knows that it should not bother you with these files.


## Deprecate flat files after inflate

In the example configuration file above, you can note that the "flat_addins.Rmd" section has a parameter `state: active` which means that `inflate_all()` will indeed inflate this file. 

If your practice of {fusen} is to inflate it once, and then continue development in the R, test and vignette files directly, then you may want to properly deprecated the flat file.   

In this case, we recommend to store your flat file in a sub-directory named "dev/dev_history/" as this will be the default behavior in a future release. Then, you can change your flat file to `state: deprecated` in the configuration file, and change both `path:` section of the file too.

## Detect all files that are not registered in configuration file

`check_not_registered_files()` shows files that are not already registered in the yaml config file.  
_Note that `check_not_registered_files()` will try to guess the source flat template, if you used {fusen} >= 0.4 before._  

The csv file "dev/config_not_registered.csv" created by `check_not_registered_files()` lists all unregistered files.
It contains three columns:

- type: The type of file among R, test or vignette
- path: The path where to find the unregistered file
- origin: If the file was created from a former flat file, the origin may be detected.
  + If the flat file detected already appears in the configuration file, the unregistered file is probably a deprecated file that needs to be deleted. But only you know. 
  + If the flat file detected is not already in the configuration file, the section for this flat file will be created during the next step with `register_all_to_config()`.
  + If no source was detected, this probably means that you created it manually.
  
Decide which files you want to delete. Then run `fusen::register_all_to_config()` to register all remaining files in the "keep" section.

Have a look at the configuration file at the end of the process to check that everything is set properly. Maybe some flat files detected should not be in `state: active` but in `state: deprecated`. You're the only one who knows.

```{r function-check_not_registered_files, filename="register_config_file"}
#' Show in a table files that are not already registered in the yaml config file
#'
#' If user start their package without 'fusen' or with version < 0.4, they need to create the config file, with already existing functions.
#'
#' @param path Path to package to check for not registered files
#' @param config_file Path to the configuration file
#' @param guess Logical. Guess if the file was inflated by a specific flat file
#' @param to_csv Logical. Whether to store along the config file, the outputs in a csv for the user to clean it manually
#' @param open Logical. Whether to open the csv of unregistered files.
#' @return Path to csv file if `to_csv` is TRUE. `dput()` of the dataframe otherwise.
#' @importFrom utils write.csv
#'
#' @seealso
#'   [register_all_to_config()] for automatically registering all files already present in the project,
#'   [inflate_all()] to inflate every flat files according to the configuration file.
#'
#' @export
check_not_registered_files <- function(path = ".", config_file, guess = TRUE, to_csv = TRUE, open = FALSE) {
  path <- normalize_path_winslash(path)

  all_r <- list.files(file.path(path, "R"), pattern = "[.]R$|[.]r$", full.names = TRUE)
  all_test <- list.files(file.path(path, "tests", "testthat"), pattern = "[.]R$|[.]r$", full.names = TRUE)
  all_vignette <- list.files(file.path(path, "vignettes"), pattern = "[.]Rmd$|[.]rmd$", full.names = TRUE)

  res <- data.frame(
    type = c(
      rep("R", length(all_r)),
      rep("test", length(all_test)),
      rep("vignette", length(all_vignette))
    ),
    path = c(
      all_r,
      all_test,
      all_vignette
    ),
    stringsAsFactors = FALSE
  )

  if (nrow(res) == 0) {
    message("There are no files in the package. Did you inflate it once?")
    return(NULL)
  }

  if (missing(config_file)) {
    config_file <- getOption("fusen.config_file", default = "dev/config_fusen.yaml")
  }

  if (file.exists(config_file)) {
    # Read config file, and remove those already there
    config_list <- yaml::read_yaml(config_file)
    all_paths_in_config <- get_list_paths(config_list)
    if (any(!is.null(all_paths_in_config))) {
      config_list_path <- normalize_path_winslash(
        all_paths_in_config,
        mustWork = FALSE
      )
      res_new <- res[!res$path %in% config_list_path, ]
      config_flat_paths <- sapply(config_list, function(x) x[["path"]])
      config_flat_paths <-
        config_flat_paths[!names(config_flat_paths) == "keep"]
    } else {
      res_new <- res
      config_flat_paths <- NULL
    }
  } else {
    res_new <- res
    config_flat_paths <- NULL
  }

  if (nrow(res_new) == 0) {
    cli::cli_alert_success("There are no unregistered files.")
    return(NULL)
  }

  # Guess those not in config_file
  # All files without path, are changed for "keep"
  if (isTRUE(guess)) {
    # List all files
    res_new$origin <- unlist(lapply(res_new$path, guess_flat_origin))
    # Change if guessed origin is already in the config file
    # This may mean that the package is not clean
    if (!is.null(config_flat_paths)) {
      res_new$origin[which(res_new$origin %in% config_flat_paths)] <-
        paste0(
          "Possibly deprecated file. Please check its link with detected flat source: ",
          res_new$origin[which(res_new$origin %in% config_flat_paths)]
        )
    }
  } else {
    res_new$origin <- "keep"
  }

  # TODO go back to relative path
  res_new$path <- gsub(paste0(normalize_path_winslash(getwd()), "/"), "", normalize_path_winslash(res_new$path, mustWork = TRUE), fixed = TRUE)

  # config_file may not exist already
  csv_file <- file.path(
    gsub(paste0(normalize_path_winslash(getwd()), "/"), "", dirname(normalize_path_winslash(config_file, mustWork = FALSE)), fixed = TRUE),
    "config_not_registered.csv"
  )

  # Save for manual modification
  if (isTRUE(to_csv)) {
    write.csv(res_new, csv_file, row.names = FALSE)
    cli::cli_text(
      cli::cli_alert_info(c(
        "\nSome files in your package are not registered in the configuration file stored in {config_file}: ",
        paste(res_new$path, collapse = ", "),
        "\n{.pkg fusen} uses a configuration file to store the structure of your package and help you clean it when needed.",
        "\nYou will find a list of unregistered files there: {.path csv_file}",
        " that you can open with {.run file.edit('{csv_file}')}",
        "\n\nDelete unregistered files that you do not need anymore. Then run {.fn fusen::register_all_to_config}.",
        "\nAfter that, this message should not appear in your next {.fn fusen::check_not_registered_files} or {.fn fusen::inflate_all} calls.",
        "\nFor more information, read `vignette('{.vignette [register-files-in-config](fusen::register-files-in-config)}', package = 'fusen')`"
      ))
    )

    if (isTRUE(open) & interactive()) {
      if (requireNamespace("rstudioapi") &&
        rstudioapi::isAvailable() &&
        rstudioapi::hasFun("navigateToFile")) {
        rstudioapi::navigateToFile(csv_file)
      } else {
        utils::file.edit(csv_file)
      }
    }

    return(csv_file)
  } else {
    # return a `dput()` to allow to add to `df_to_config()`
    # dput()
    # return(dput(res_new, file = nullfile()))
    return(res_new)
  }
}

#' Guess flat file of origin of a script
#'
#' @param path Path of the script to test
#' @noRd
guess_flat_origin <- function(path) {
  lines <- readLines(path)

  guess_path <- sub(
    ".* from\\s*(/){0,1}(.+[.].{1}md).*",
    "\\2",
    lines[grep("(G|g)enerated by \\{fusen\\} from", lines)][1]
  )

  guess_path <- normalize_path_winslash(guess_path, mustWork = FALSE)
  if (file.exists(guess_path)) {
    guess_path <- gsub(
      paste0(normalize_path_winslash(getwd()), "/"),
      "",
      normalize_path_winslash(guess_path, mustWork = FALSE)
    )
    return(guess_path)
  } else {
    return("No existing source path found.")
  }
}

#' Get all paths from a config list, except some
#' @param config_list List as read from config.yaml file
#' @noRd
get_list_paths <- function(config_list) {
  unlist(lapply(config_list, function(x) {
    if (x$path == "keep") x$path <- NULL
    x$state <- NULL
    x
  }))
}
```

```{r example-check_not_registered_files, eval=FALSE}
#' \dontrun{
# Run this on the current package in development
out_csv <- check_not_registered_files()
file.edit(out_csv)
#' }
```

<!-- Use eval=FALSE because inflate cannot work inside a Rmd vignette -->

```{r example2-check_not_registered_files, eval=FALSE}
# Or you can try on the reproducible example
dummypackage <- tempfile("clean")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage, {
  suppressMessages(
    inflate(
      pkg = dummypackage,
      flat_file = flat_file,
      vignette_name = "Get started",
      check = FALSE,
      open_vignette = FALSE
    )
  )

  # Add a not registered file to the package
  cat("# test R file\n", file = file.path(dummypackage, "R", "to_keep.R"))

  # Use the function to check the list of files
  out_csv <- check_not_registered_files(dummypackage)
  out_csv
  # Read the csv to see what is going on
  content_csv <- read.csv(out_csv, stringsAsFactors = FALSE)
  content_csv
  # Keep it all or delete some files, and then register all remaining
  out_config <- register_all_to_config()
  out_config
  # Open the out_config file to see what's going on
  yaml::read_yaml(out_config)
})
unlink(dummypackage, recursive = TRUE)
```


```{r tests-check_not_registered_files}
dummypackage <- tempfile("registered")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(
  add_flat_template(
    pkg = dummypackage,
    overwrite = TRUE,
    open = FALSE
  )
)
flat_file <- dev_file[grepl("flat_", dev_file)]

usethis::with_project(dummypackage, {
  test_that("check_not_registered_files returns message if empty", {
    expect_true(inherits(check_not_registered_files, "function"))
    expect_message(
      check_not_registered_files(open = FALSE),
      "There are no files in the package"
    )
  })

  # Inflate once
  suppressMessages(
    inflate(
      pkg = dummypackage,
      flat_file = flat_file,
      vignette_name = "Get started",
      check = FALSE,
      open_vignette = FALSE
    )
  )

  test_that("guess_flat_origin works", {
    guessed_path <- guess_flat_origin(
      file.path(dummypackage, "R", "my_median.R")
    )
    # Relative path
    expect_equal(guessed_path, file.path("dev", "flat_full.Rmd"))

    guessed_path <- guess_flat_origin(
      file.path(dummypackage, "dev", "0-dev_history.Rmd")
    )
    expect_true(grepl("No existing source path found", guessed_path))
  })

  test_that("check_not_registered_files works", {
    # All files were registered during inflate
    expect_true(
      file.exists(
        file.path(dummypackage, "dev", "config_fusen.yaml")
      )
    )
    expect_message(
      out_csv <- check_not_registered_files(open = FALSE),
      regexp = "There are no unregistered files"
    )

    # Delete config file to check if al sub-functions work
    file.remove(file.path(dummypackage, "dev", "config_fusen.yaml"))
    expect_message(
      out_csv <- check_not_registered_files(open = FALSE),
      regexp = "Some files in your package are not registered in the configuration file"
    )

    content_csv <- read.csv(out_csv, stringsAsFactors = FALSE)
    expect_true(all(names(content_csv) %in% c("type", "path", "origin")))
    expect_equal(content_csv[["type"]], c("R", "R", "test", "test", "vignette"))
    # Relative path
    expect_equal(
      content_csv[["path"]],
      c(
        "R/my_median.R",
        "R/my_other_median.R",
        "tests/testthat/test-my_median.R",
        "tests/testthat/test-my_other_median.R",
        "vignettes/get-started.Rmd"
      )
    )
  })

  test_that("guess_flat_origin output works with df_to_config", {
    out_csv <- "dev/config_not_registered.csv"
    # Include it in df_to_config()

    out_config <- df_to_config(
      df_files = out_csv
    )
    out_config_content <- yaml::read_yaml(out_config)
    expect_true(all(names(out_config_content) %in% c("flat_full.Rmd", "keep")))
    expect_equal(
      names(out_config_content[["flat_full.Rmd"]]),
      c("path", "state", "R", "tests", "vignettes")
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["R"]],
      c("R/my_median.R", "R/my_other_median.R")
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["tests"]],
      c(
        "tests/testthat/test-my_median.R",
        "tests/testthat/test-my_other_median.R"
      )
    )
    expect_equal(
      out_config_content[["flat_full.Rmd"]][["vignettes"]],
      c("vignettes/get-started.Rmd")
    )

    # rstudioapi::navigateToFile(out_config)
  })

  # Test add a R file manually and include in "keep" after `check_not_registered_files()`
  cat("# test R file\n", file = file.path(dummypackage, "R", "to_keep.R"))

  test_that("check_not_registered_files can help manually fill config", {
    expect_message(
      out_csv <- check_not_registered_files(open = FALSE),
      "Some files in your package are not registered in the configuration file"
    )
    content_csv <- read.csv(out_csv, stringsAsFactors = FALSE)
    expect_true(
      grepl(
        "No existing source path found",
        content_csv[grepl("to_keep.R", content_csv[, "path"]), "origin"]
      )
    )

    # Add in the yaml file with `df_to_config()`
    keep_to_add_to_config <- content_csv[
      grepl("to_keep.R", content_csv[, "path"]),
    ]
    keep_to_add_to_config$origin <- "keep"

    out_config <- df_to_config(keep_to_add_to_config)
    out_config_content <- yaml::read_yaml(out_config)
    expect_equal(out_config_content$keep$R, "R/to_keep.R")

    expect_message(
      out_csv <- check_not_registered_files(open = FALSE),
      "There are no unregistered files"
    )
    expect_true(is.null(out_csv))

    # Add same file in the yaml file with `df_to_config()` using different origin (existing one, but duplicate R file) ----
    cat("fake flat\n", file = file.path("dev", "flat_other.Rmd"))
    keep_to_add_to_config$origin <- "dev/flat_other.Rmd"

    expect_error(
      df_to_config(keep_to_add_to_config),
      "Some paths would appear multiple times in the future config file."
    )
    out_config_content <- yaml::read_yaml(out_config)
    expect_equal(out_config_content$keep$R, "R/to_keep.R")

    # Add same file in the yaml file with `df_to_config()` using different origin (not existing) ----

    keep_to_add_to_config$origin <- "dev/flat_dont_exists.Rmd"

    expect_error(
      df_to_config(keep_to_add_to_config),
      "Some 'origin' in df_files do not exist: row 1: dev/flat_dont_exists.Rmd"
    )
  })
})
```


## How `register_all_to_config()` works

If all files of the current state are legitimate, then, you can register everything in the config file.

Run `register_all_to_config()` in your current package to create the "dev/config_fusen.yaml" that registers all your files. You will note a "keep" section, which lists all files for which the source was not guessed.

This function deletes the "config_not_registered.csv" created with `check_not_registered_files()`. 

```{r function-register_all_to_config}
#' Include all existing package files in the config file
#'
#' Helps transition from non-fusen packages or made with earlier version
#'
#' @param pkg Path to the package from which to add file to configuration file
#' @param config_file Path to the configuration file
#' @return Invisible path to 'fusen' configuration file
#'
#' @seealso
#'   [check_not_registered_files()] for the list of files not already associated with a flat file in the config file,
#'
#' @export
register_all_to_config <- function(pkg = ".", config_file) {
  if (missing(config_file)) {
    config_file <- getOption(
      "fusen.config_file",
      default = "dev/config_fusen.yaml"
    )
  }

  # Use the function to check the list of files
  out_df <- check_not_registered_files(
    pkg,
    config_file = config_file,
    to_csv = FALSE,
    open = FALSE
  )


  if (is.null(out_df)) {
    message("There is no file to register or everything was already registered")
    return(config_file)
  }

  # Deal with files linked to a flat file that is already registered
  # Change them to "keep"
  out_df_keep <- deal_with_registered_keep(out_df)
  out_config <- df_to_config(
    df_files = out_df_keep,
    clean = FALSE,
    config_file = config_file
  )

  # Delete out_df
  csv_file <- file.path(
    gsub(
      paste0(normalize_path_winslash(getwd()), "/"),
      "",
      dirname(normalize_path_winslash(config_file, mustWork = FALSE)),
      fixed = TRUE
    ),
    "config_not_registered.csv"
  )
  if (file.exists(csv_file)) {
    cli::cat_rule(paste("Delete", csv_file))
    file.remove(csv_file)
  }

  return(invisible(out_config))
}

#' Deal with files linked to a flat file that is already registered and other files to keep
#' @param df dataframe as read from [check_not_registered_files()]
#' @noRd
deal_with_registered_keep <- function(df) {
  w.keep <- grep("No existing source path found|Possibly deprecated file", df[["origin"]])
  df[["origin"]][w.keep] <- "keep"

  return(df)
}
```

```{r example-register_all_to_config-1, eval=FALSE}
#' \dontrun{
# Usually run this one inside the current project
# Note: running this will write "dev/config_fusen.yaml" in your working directory
register_all_to_config()
#' }
```

<!-- Use eval=FALSE because inflate cannot work inside a Rmd vignette -->

```{r example-register_all_to_config-2, eval=FALSE}
# Or you can try on the reproducible example
dummypackage <- tempfile("register")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage, {
  suppressMessages(
    inflate(
      pkg = dummypackage,
      flat_file = flat_file,
      vignette_name = "Get started",
      check = FALSE,
      open_vignette = FALSE
    )
  )
  out_path <- register_all_to_config(dummypackage)

  # Look at the output
  yaml::read_yaml(out_path)
})
```

```{r tests-register_all_to_config}
dummypackage <- tempfile("register")
dir.create(dummypackage)
dir.create(file.path(dummypackage, "fusentest"))
dummypackage_fixed <- file.path(dummypackage, "fusentest")

# {fusen} steps
fill_description(pkg = dummypackage_fixed, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage_fixed, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage_fixed, {
  suppressMessages(
    inflate(
      pkg = dummypackage_fixed,
      flat_file = flat_file,
      vignette_name = "Get started",
      check = FALSE,
      open_vignette = FALSE
    )
  )
})

# Add a not registered file to the package
cat("# test R file\n", file = file.path(dummypackage_fixed, "R", "to_keep.R"))


test_that("register_all_to_config can be run twice", {
  expect_true(inherits(register_all_to_config, "function"))

  usethis::with_project(dummypackage_fixed, {
    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )
    expect_equal(out_path, file.path("dev", "config_fusen.yaml"))

    # What happens if everything is already registered? ----
    expect_message(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = "There is no file to register"
    )

    expect_equal(out_path, file.path("dev", "config_fusen.yaml"))

    # Add a new file to register from a new flat file ----
    add_flat_template(template = "add", flat_name = "new_one", open = FALSE)
    # Without vignette first
    suppressMessages(
      inflate(
        pkg = dummypackage_fixed,
        flat_file = "dev/flat_new_one.Rmd",
        vignette_name = NA,
        check = FALSE,
        open_vignette = FALSE
      )
    )

    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )

    # With vignette then
    suppressMessages(
      inflate(
        pkg = dummypackage_fixed,
        flat_file = "dev/flat_new_one.Rmd",
        vignette_name = "new_one",
        check = FALSE,
        open_vignette = FALSE
      )
    )

    expect_error(
      out_path <- register_all_to_config(dummypackage_fixed),
      regexp = NA
    )
  })
})

test_that("config file is correctly built after half register", {
  out_actual <- yaml::read_yaml(file.path(dummypackage_fixed, "dev", "config_fusen.yaml"))
  # To update
  # file.copy(file.path(dummypackage_fixed, "dev", "config_fusen.yaml"), here::here("tests/testthat/config_fusen_register.yaml"), overwrite = TRUE)
  if (file.exists("config_fusen_register.yaml")) {
    out_expected <- yaml::read_yaml("config_fusen_register.yaml")
  } else {
    # during dev in root directory
    out_expected <- yaml::read_yaml(here::here("tests/testthat/config_fusen_register.yaml"))
  }

  expect_equal(out_actual, out_expected)
})

unlink(dummypackage, recursive = TRUE)

# register_all_to_config runs properly after check_not_registered ----

dummypackage <- tempfile("register")
dir.create(dummypackage)
# unlink(dummypackage, recursive = TRUE)
# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE))
flat_file <- dev_file[grepl("flat_", dev_file)]
# Inflate once
usethis::with_project(dummypackage, {
  suppressMessages(
    inflate(
      pkg = dummypackage,
      flat_file = flat_file,
      vignette_name = "Get started",
      check = FALSE,
      open_vignette = FALSE
    )
  )

  # Add a not registered file to the package
  cat("# test R file\n", file = file.path(dummypackage, "R", "to_keep.R"))

  test_that("register_all_to_config runs properly after check_not_registered", {
    suppressMessages(check_not_registered_files(open = FALSE))
    # expect csv contains : No existing source path found
    not_registered <- "dev/config_not_registered.csv"

    not_registered_content <- read.csv(not_registered, stringsAsFactors = FALSE)
    expected_registered <- structure(
      list(
        type = "R",
        path = "R/to_keep.R",
        origin = "No existing source path found."
      ),
      class = "data.frame",
      row.names = c(NA, -1L)
    )
    expect_equal(not_registered_content, expected_registered)
    suppressMessages(register_all_to_config())
    # expect deleted config_not_registered.csv
    expect_false(file.exists(not_registered))
    # expect cnofig file with "keep" section
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    expect_equal(config_file[["keep"]][["R"]], "R/to_keep.R")
    # Create an obsolete file
    file.copy("R/my_median.R", "R/my_old_fun.R")
    expect_message(check_not_registered_files(open = FALSE), "Some files in your package are not registered")
    # expect csv contains : Possibly deprecated file issued from flat...
    not_registered_content <- read.csv(not_registered, stringsAsFactors = FALSE)
    expected_registered <- structure(
      list(
        type = "R",
        path = "R/my_old_fun.R",
        origin = "Possibly deprecated file. Please check its link with detected flat source: dev/flat_full.Rmd"
      ),
      class = "data.frame",
      row.names = c(NA, -1L)
    )

    expect_equal(not_registered_content, expected_registered)
  })

  test_that("register_all_to_config can append new files in keep section", {
    suppressMessages(register_all_to_config())
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    expect_equal(
      sort(config_file[["keep"]][["R"]]),
      sort(c("R/to_keep.R", "R/my_old_fun.R"))
    )
    # expect config file with my_old_fun.R in "keep" section
    file.remove("R/my_old_fun.R")
    expect_message(
      check_not_registered_files(open = FALSE),
      regexp = "There are no unregistered files"
    )

    # register_all_to_config throws an error if there is something to add to the config
    file.copy("R/my_median.R", "R/my_second_old_fun.R")
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    expect_error(
      register_all_to_config(),
      regexp = "Some paths in config_file do not exist: R/my_old_fun.R"
    )

    # Clean the missing file and it should be good to add the second new file
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    config_file$keep$R <- "R/to_keep.R"
    write_yaml_verbatim(config_file, "dev/config_fusen.yaml")

    expect_message(
      register_all_to_config(),
      regexp = "R: R/my_second_old_fun.R was added to the config file"
    )
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    expect_equal(
      sort(config_file[["keep"]][["R"]]),
      sort(c("R/to_keep.R", "R/my_second_old_fun.R"))
    )

    # add new file to add to keep
    cat("new_to_keep\n", file = "R/newfile_to_keep.R")
    expect_message(
      register_all_to_config(),
      regexp = "R: R/newfile_to_keep.R was added to the config file"
    )
    config_file <- yaml::read_yaml("dev/config_fusen.yaml")
    expect_equal(
      sort(config_file[["keep"]][["R"]]),
      sort(c("R/to_keep.R", "R/my_second_old_fun.R", "R/newfile_to_keep.R"))
    )
  })
})
unlink(dummypackage, recursive = TRUE)
```


<!-- ### Protect existing R, tests and vignettes files -->

<!-- `df_to_config()` allows to add your own list of files that you want to `keep` in your package, despite not being created with a flat file.   -->
<!-- This is important if you started to develop without {fusen}, and start using a flat file from now on, so that {fusen} does not delete your existing files. -->

```{r function-df_to_config, filename="register_config_file"}
#' Add a tibble of files and types to add to the 'fusen'
#'  config file along with inflate parameters
#'
#' @param df_files A data.frame with 'type' and 'path' columns
#' or a csv file path as issued from `[check_not_registered_files()]`
#' or nothing (and it will take the csv file in "dev/")
#' @param flat_file_path Character. Usually set to `"keep"` for users.
#' You can use the name of the origin flat file but this is more of
#' an internal use, as inflating the flat file should have the same result.
#' @param state Character. Whether if the flat file is `active` or `deprecated`.
#' @param config_file Path to the configuration file
#' @param force Logical. Whether to force writing the configuration
#' file even is some files do not exist.
#' @param clean Logical (TRUE, FALSE) or character ("ask", "yes", "no).
#' Whether to delete files created in a previous version of this flat file
#' Default is set to "ask" during `inflate()` of a specific flat file,
#' as the list should only contain files created during the inflate.
#' This could be set to FALSE with a direct use of `df_to_config()` too.
#' This is forced to FALSE for the "keep" section.
#' @param inflate_parameters list of parameters passed through
#' a call to `inflate()`
#' @param update_params Logical. Whether to update the inflate parameters
#' along with other information in the config file.

#' @importFrom stats setNames
#' @importFrom utils read.csv
#' @importFrom cli cli_alert_warning cli_alert_info
#'
#' @return Config file path.
#' Side effect: create a yaml config file.
#'
#' @seealso
#'   [check_not_registered_files()] for the list of files not already
#'  associated with a flat file in the config file,
#'   [register_all_to_config()] for automatically registering
#'  all files already present in the project
#'
#' @noRd

df_to_config <- function(
  df_files,
  flat_file_path = "keep",
  state = c("active", "deprecated"),
  config_file,
  force = FALSE,
  clean = "ask",
  inflate_parameters = NULL,
  update_params = TRUE
) {
  if (missing(config_file)) {
    config_file <- getOption(
      "fusen.config_file",
      default = "dev/config_fusen.yaml"
    )
  }

  state <- match.arg(state, several.ok = FALSE)

  # User entry verifications
  if (missing(df_files)) {
    df_files <- file.path(dirname(config_file), "config_not_registered.csv")
    df_files <- deal_with_registered_keep(df_files)
  }

  if (!is.data.frame(df_files) && file.exists(df_files)) {
    df_files <- read.csv(df_files, stringsAsFactors = FALSE)
  } else if (!is.data.frame(df_files) && !file.exists(df_files)) {
    stop(
      "'",
      df_files,
      "' does not exist. You can run ",
      "`check_not_registered_files()` before."
    )
  }

  # Then if is.data.frame(df_files)
  if (!all(c("type", "path") %in% names(df_files))) {
    stop("df_files should contains two columns named: 'type' and 'path'")
  }

  if (!"origin" %in% names(df_files)) {
    df_files[["origin"]] <- flat_file_path
  } else {
    # check origin exists
    df_files_origin <- df_files[["origin"]]
    df_files_origin <- df_files_origin[df_files_origin != "keep"]
    all_exists <- file.exists(df_files_origin)
    if (!all(all_exists)) {
      msg <- paste(
        "Some 'origin' in df_files do not exist:",
        paste(
          paste0(
            "row ",
            which(!all_exists),
            ": ",
            df_files[["origin"]][!all_exists]
          ),
          collapse = ", "
        )
      )
      if (isTRUE(force)) {
        cli_alert_warning(
          paste(
            msg,
            "\nHowever, you forced to write it in the yaml",
            " file with `force = TRUE`."
          )
        )
      } else {
        stop(msg)
      }
    }
  }

  if (flat_file_path != "keep") {
    flat_file_path_relative <- gsub(
      paste0(normalize_path_winslash("."), "/"),
      "",
      normalize_path_winslash(flat_file_path, mustWork = TRUE),
      fixed = TRUE
    )
  }

  if (!all(
    grepl(
      "^R$|^r$|^test$|^tests$|^vignette$|^vignettes$",
      df_files[["type"]]
    )
  )) {
    stop("Only types 'R', 'test' or 'vignette' are allowed")
  }
  all_exists <- file.exists(df_files[["path"]])
  if (!all(all_exists)) {
    msg <- paste(
      "Some 'path' in df_files do not exist:",
      paste(
        paste0(
          "row ",
          which(!all_exists),
          "- ",
          df_files[["type"]][!all_exists],
          ": ",
          df_files[["path"]][!all_exists]
        ),
        collapse = ", "
      )
    )

    if (isTRUE(force)) {
      cli_alert_warning(
        paste(
          msg,
          "\nHowever, you forced to write it in the yaml file with `force = TRUE`."
        )
      )
    } else {
      stop(msg)
    }
  }

  if (!is.null(inflate_parameters) & flat_file_path == "keep") {
    stop(
      "The purpose of using \"keep\" is to store files",
      " created without inflate(). ",
      " Therefore it is not allowed to provide inflate_parameters"
    )
  }

  # Remove common part between config_file and all path
  # to get relative paths to project

  # TODO - When path does not exists, normalizePath does not correctly
  # use path.expand.
  # All path should exists. It is tested above.
  if (!isTRUE(force) || isTRUE(all(file.exists(df_files$path)))) {
    df_files$path <- gsub(
      paste0(normalize_path_winslash("."), "/"),
      "",
      normalize_path_winslash(df_files$path, mustWork = TRUE),
      fixed = TRUE
    )
  }

  # All origin path should exist, if not "keep"
  if (
    !isTRUE(force) ||
      isTRUE(all(file.exists(df_files$origin[df_files$origin != "keep"])))
  ) {
    df_files$origin[df_files$origin != "keep"] <- gsub(
      paste0(normalize_path_winslash("."), "/"),
      "",
      normalize_path_winslash(
        df_files$origin[df_files$origin != "keep"],
        mustWork = TRUE
      ),
      fixed = TRUE
    )
  } else if (
    isFALSE(all(file.exists(df_files$origin[df_files$origin != "keep"])))
  ) {
    warning(
      "Please open a bug on {fusen} package with this complete message:\n",
      "There is an error in the df_to_config process.\n",
      "Files origin do not exist but will be registered as is in the config file:\n",
      paste(
        df_files$origin[
          !file.exists(df_files$origin[df_files$origin != "keep"])
        ],
        collapse = ", "
      )
    )
  }

  if (any(duplicated(df_files$path))) {
    msg <- paste(
      "Some paths appear multiple times in df_files. Please remove duplicated rows: ",
      paste(unique(df_files$path[duplicated(df_files$path)]), collapse = ", ")
    )

    if (isTRUE(force)) {
      cli_alert_warning(
        paste(
          msg,
          "\nHowever, you forced to write it in the yaml file with `force = TRUE`."
        )
      )
    } else {
      stop(msg)
    }
  }

  if (file.exists(config_file)) {
    complete_yaml <- read_yaml(config_file)

    yaml_paths <- get_list_paths(complete_yaml)
    if (all(is.null(yaml_paths))) {
      complete_yaml <- list()
    } else if (any(!is.null(yaml_paths))) {
      yaml_paths <- yaml_paths[!grepl("inflate\\.", names(yaml_paths))]
      all_exists <- file.exists(yaml_paths)
      if (!all(all_exists)) {
        msg <- paste(
          "Some paths in config_file do not exist:",
          paste(
            yaml_paths[!all_exists],
            collapse = ", "
          ),
          ".\n",
          "Please open the configuration file: ",
          config_file,
          " to verify, and delete the non-existing files if needed."
        )
        if (isTRUE(force)) {
          cli_alert_warning(
            paste(
              msg,
              "However, you forced to write it in the yaml file with `force = TRUE`."
            )
          )
        } else {
          stop(msg)
        }
      }
    }
  } else {
    complete_yaml <- list()
  }

  each_flat_file_path <- unique(c(flat_file_path, df_files[["origin"]]))
  if (length(state) != length(each_flat_file_path)) {
    state <- rep(state, length.out = length(each_flat_file_path))
  }
  all_groups_list <- lapply(
    seq_along(each_flat_file_path),
    function(x) {
      update_one_group_yaml(
        df_files,
        complete_yaml,
        each_flat_file_path[x],
        state = state[x],
        clean = ifelse(each_flat_file_path[x] == "keep", FALSE, clean),
        inflate_parameters = inflate_parameters,
        update_params = update_params
      )
    }
  ) %>%
    setNames(basename(each_flat_file_path))

  all_modified <- names(complete_yaml)[names(complete_yaml) %in% names(all_groups_list)]

  if (length(all_modified) != 0) {
    cli_alert_info(
      paste0(
        "Some files group already existed and were modified: ",
        paste(all_modified, collapse = ", ")
      )
    )
    complete_yaml[all_modified] <- NULL
  }

  # Combine with complete_yaml
  complete_yaml <- c(complete_yaml, all_groups_list)
  # order according to name without path so that flat_2 is after flat.Rmd
  complete_yaml <- complete_yaml[order(
    sub("(?<!^|[.]|/)[.][^.]+$", "", names(complete_yaml), perl = TRUE)
  )]

  # Get duplicated paths after update
  yaml_paths <- unlist(complete_yaml)
  # Except info on state
  yaml_paths <- yaml_paths[!grepl("[.]state$", names(yaml_paths))]
  yaml_paths <- yaml_paths[!grepl("inflate\\.", names(yaml_paths))]

  if (any(duplicated(yaml_paths))) {
    which_file <- files_list_to_vector(
      lapply(complete_yaml, files_list_to_vector)
    )

    if (isTRUE(force)) {
      cli_alert_warning("Some paths appear multiple times in the config file. The yaml was forced with `force = TRUE`. Please verify the source of these scripts in the existing yaml file or in the df_files provided:\n", paste(which_file[duplicated(yaml_paths)], collapse = ",\n"))
    } else {
      stop("Some paths would appear multiple times in the future config file. The yaml has not been created. Please verify the source of these scripts in the existing yaml file or in the df_files provided:\n", paste(which_file[duplicated(yaml_paths)], collapse = ",\n"), "\nOr use `force = TRUE`")
    }
  }

  write_yaml_verbatim(complete_yaml, file = config_file)

  return(config_file)
}


#' Make sure yaml returns true/false as is, and not "yes/no"
#' @importFrom yaml write_yaml read_yaml
#' @noRd
write_yaml_verbatim <- function(x, file) {
  write_yaml(
    x,
    file = file,
    handlers = list(
      logical = function(x) {
        result <- ifelse(x, "true", "false")
        class(result) <- "verbatim"
        return(result)
      }
    )
  )
}

#' Extract name of file along with type to inform the user
#' @param list_of_files A named list of files
#' @noRd
files_list_to_vector <- function(list_of_files) {
  lapply(seq_along(list_of_files), function(x) {
    if (length(list_of_files[[x]]) != 0) {
      paste(names(list_of_files[x]), list_of_files[[x]], sep = ": ")
    }
  }) %>% unlist()
}

#' Update one group in the complete yaml as list
#' @param complete_yaml The list as output of config_yaml file
#' @param flat_file_path The group to update
#' @param state Character. See `df_to_config()`.
#' @param clean Logical (TRUE, FALSE) or character ("ask", "yes", "no).
#'  See `df_to_config()`.
#' @param inflate_parameters See `df_to_config()`.
#' @param update_params Logical. See `df_to_config()`.
#' @importFrom cli cli_alert_warning cli_alert_success
#' @noRd
update_one_group_yaml <- function(
  df_files,
  complete_yaml,
  flat_file_path,
  state = c("active", "deprecated"),
  clean = "ask",
  inflate_parameters = NULL,
  update_params = TRUE
) {
  state <- match.arg(state, several.ok = FALSE)
  all_keep_before <- complete_yaml[[basename(flat_file_path)]]

  # Only files from df_files will be listed
  df_files_filtered <- df_files[df_files[["origin"]] == flat_file_path, ]

  # All already in the list will be deleted except if clean is FALSE
  if (isTRUE(clean) || clean %in% c("yes", "ask")) {
    this_group_list <- list(
      path = flat_file_path,
      state = state,
      R = c(df_files_filtered[["path"]][
        grepl("^R$|^r$", df_files_filtered[["type"]])
      ]),
      tests = c(df_files_filtered[["path"]][
        grepl("^test$|^tests$", df_files_filtered[["type"]])
      ]),
      vignettes = c(df_files_filtered[["path"]][
        grepl("^vignette$|^vignettes$", df_files_filtered[["type"]])
      ])
    )
  } else if (isFALSE(clean) || clean %in% c("no")) {
    this_group_list <- list(
      path = flat_file_path,
      state = state,
      R = unique(c(
        # new ones
        df_files_filtered[["path"]][
          grepl("^R$|^r$", df_files_filtered[["type"]])
        ],
        # previous ones
        unlist(all_keep_before[["R"]])
      )),
      tests = unique(c(
        # new ones
        df_files_filtered[["path"]][
          grepl("^test$|^tests$", df_files_filtered[["type"]])
        ],
        # previous ones
        unlist(all_keep_before[["tests"]])
      )),
      vignettes = unique(c(
        # new ones
        df_files_filtered[["path"]][
          grepl(
            "^vignette$|^vignettes$",
            df_files_filtered[["type"]]
          )
        ],
        # previous ones
        unlist(all_keep_before[["vignettes"]])
      ))
    )
  } else {
    stop("clean should be TRUE, FALSE, 'yes', 'no' or 'ask'")
  }

  this_group_list_return <- this_group_list
  if (!is.null(inflate_parameters)) {
    if (isFALSE(update_params)) {
      inflate_parameters_new <-
        all_keep_before[["inflate"]]
      # Still modify flat_file_path and vignette_name
      inflate_parameters_new[["flat_file"]] <-
        inflate_parameters$flat_file
      inflate_parameters_new[["vignette_name"]] <-
        inflate_parameters$vignette_name
    } else if (isTRUE(update_params)) {
      inflate_parameters_new <- inflate_parameters
    }
    this_group_list_return <- c(
      this_group_list,
      list(inflate = inflate_parameters_new)
    )
  }

  # Messages only
  all_names <- c("R", "tests", "vignettes")
  # names(this_group_list_message)
  files_removed <- lapply(
    all_names,
    function(x) {
      setdiff(
        all_keep_before[[x]],
        this_group_list_return[[x]]
      )
    }
  ) %>%
    setNames(all_names)
  files_removed_vec <- files_list_to_vector(files_removed)

  files_added <- lapply(
    all_names,
    function(x) {
      setdiff(
        this_group_list_return[[x]],
        all_keep_before[[x]]
      )
    }
  ) %>%
    setNames(all_names)
  files_added_vec <- files_list_to_vector(files_added)

  if (!is.null(files_removed_vec) || length(files_removed_vec) != 0) {
    if (clean == "ask") {
      cli_alert_warning(
        paste0(
          "Some files are not anymore created from ",
          flat_file_path,
          ".\n",
          "You may have rename some functions or moved them to another flat:",
          "\n",
          paste(files_removed_vec, collapse = ", "),
          ".\n\n",
          "Below, you are ask if you want to remove them from the repository.",
          "\n\n",
          "Note: to not see this message again, use `clean = TRUE` in the ",
          "`inflate()` command of this flat file : ",
          flat_file_path,
          ".\n",
          "Use with caution. ",
          "It is recommended to use git to check the changes...\n"
        )
      )
      sure <- paste(
        paste(files_removed_vec, collapse = ", "),
        "\nDo you want to remove all these files from the repository? (y/n)\n"
      )

      do_it <- readline(sure) == "y" || readline(sure) == "yes"
    } else if (isTRUE(clean) || clean == "yes") {
      do_it <- TRUE
    } else if (isFALSE(clean) || clean == "no") {
      do_it <- FALSE
    } else {
      stop("clean should be TRUE, FALSE, 'yes', 'no' or 'ask'")
    }

    if (isTRUE(do_it)) {
      files_removed_filename <- unlist(files_removed)
      files_removed_filename_exists <-
        files_removed_filename[file.exists(files_removed_filename)]
      file.remove(files_removed_filename_exists)

      silent <- lapply(
        paste(
          files_removed_vec,
          "was removed from the config file",
          "and from the repository"
        ),
        cli_alert_warning
      )
    } else if (isFALSE(do_it)) {
      silent <- lapply(
        paste(
          files_removed_vec,
          "was removed from the config file",
          "but kept in the repository"
        ),
        cli_alert_warning
      )
    }
  }
  if (!is.null(files_added_vec) || length(files_added_vec) != 0) {
    silent <- lapply(
      paste(files_added_vec, "was added to the config file"),
      cli_alert_success
    )
  }

  return(this_group_list_return)
}
```

```{r dev-df_to_config, eval=FALSE}
# Examples not exported
# Add your own list of files to "keep",
# if they are not in any flat file.
# Otherwise, they may be deleted with your next `inflate()`
my_files_to_protect <- tibble::tribble(
  ~type,
  ~path,
  "R",
  "R/zaza.R",
  "R",
  "R/zozo.R",
  "test",
  "tests/testthat/test-zaza.R",
  "vignette",
  "vignettes/my-zaza-vignette.Rmd"
)

#' \dontrun{
# This code writes in the current user working directory
df_to_config(my_files_to_protect)
#' }

#' \dontrun{
# This code writes in the current user working directory

# Provide a list of `inflate()` parameters if you wish them
# to be added in the dev/config_fusen.yaml file
# This is usually for {fusen} internal use during `inflate()`.

# This example proposes to write all output parameters
# of a specific flat file in the config file:
# files inflated and inflate parameters
fake_flat_file <- "dev/flat_minimal.Rmd"

files_created_from_fake_flat <- structure(
  list(
    type = c("R", "test", "vignette"),
    path = c(
      "R",
      "my_fun.R",
      "tests/testthat",
      "test-my_fun.R",
      "vignettes/minimal.Rmd"
    )
  ),
  row.names = c(NA, -3L),
  class = c("tbl_df", "tbl", "data.frame")
)

# This code writes in the current user working directory
config_file <- df_to_config(
  df_files = files_created_from_fake_flat,
  flat_file_path = fake_flat_file,
  clean = TRUE,
  state = "active",
  force = TRUE,
  inflate_parameters = list(
    flat_file = fake_flat_file,
    vignette_name = "My new vignette",
    open_vignette = FALSE,
    check = FALSE,
    document = TRUE,
    overwrite = "yes",
    clean = "ask"
  )
)
#' }
```

```{r tests-df_to_config}
# Test update_one_group_yaml ----
temp_clean_inflate <- tempfile(pattern = "clean.update.config")
dir.create(temp_clean_inflate)

withr::with_dir(temp_clean_inflate, {
  # Need to force edition to allow expect_snapshot
  # As we are in another directory using with_dir()
  local_edition(3)
  # Fix output conditions for this test for snapshots
  local_reproducible_output(
    width = 100,
    crayon = FALSE,
    unicode = FALSE,
    rstudio = FALSE,
    hyperlinks = FALSE,
    lang = "en",
    .env = parent.frame()
  )

  dir.create(file.path("R"))
  dir.create(file.path("tests", "testthat"), recursive = TRUE)
  dir.create(file.path("vignettes"))
  dir.create(file.path("dev"))

  cat("# test R file\n", file = file.path("R", "to_keep.R"))
  cat("# test R file\n", file = file.path("R", "to_remove.R"))
  cat(
    "# test test file\n",
    file = file.path("tests", "testthat", "test-zaza.R")
  )
  cat("# test flat file\n", file = file.path("dev", "flat_test.Rmd"))


  all_files <- tibble::tribble(
    ~type,
    ~path,
    "R",
    "R/to_keep.R",
    "R",
    "R/to_remove.R",
    "test",
    "tests/testthat/test-zaza.R"
  )


  # Get all messages once
  expect_snapshot(
    df_to_config(
      all_files,
      flat_file_path = "dev/flat_test.Rmd",
      state = "active",
      inflate_parameters = list(
        flat_file = "dev/flat_test.Rmd",
        vignette_name = "My new vignette",
        open_vignette = FALSE,
        check = FALSE,
        document = TRUE,
        overwrite = "yes",
        clean = "ask"
      )
    )
  )

  config_file <- "dev/config_fusen.yaml"


  # Simulate function to_remove() was changed for to_add()
  # Then file to_remove.R should be removed
  # from the config file and from the repository
  cat("# test R file\n", file = file.path("R", "to_add.R"))

  all_files_new <- tibble::tribble(
    ~origin,
    ~type,
    ~path,
    "dev/flat_test.Rmd",
    "R",
    "R/to_keep.R",
    "dev/flat_test.Rmd",
    "R",
    "R/to_add.R",
    "dev/flat_test.Rmd",
    "test",
    "tests/testthat/test-zaza.R"
  )

  # Get all messages once with snapshot
  expect_snapshot(
    update_one_group_yaml(
      all_files_new,
      complete_yaml = yaml::read_yaml(config_file),
      flat_file_path = "dev/flat_test.Rmd",
      state = "active",
      clean = TRUE,
      inflate_parameters = list(
        flat_file = "dev/flat_test.Rmd",
        vignette_name = "My new vignette",
        open_vignette = FALSE,
        check = FALSE,
        document = TRUE,
        overwrite = "yes",
        clean = TRUE
      )
    )
  )

  test_that("update_one_group_yaml clean old files", {
    expect_true(file.exists("R/to_add.R"))
    expect_false(file.exists("R/to_remove.R"))
    expect_true(file.exists("tests/testthat/test-zaza.R"))
  })

  if (interactive()) {
    # Allows to test in interactive session
    # to see if you were asked to remove the file
    file.create(file.path("R", "to_remove.R"))
    test_that("update_one_group_yaml file is back before interactive", {
      expect_true(file.exists("R/to_add.R"))
      expect_true(file.exists("R/to_remove.R"))
      expect_true(file.exists("tests/testthat/test-zaza.R"))
    })

    cli::cat_rule(
      "Test: You should be asked a question: please answer 'y' during tests"
    )
    update_one_group_yaml(
      all_files_new,
      complete_yaml = yaml::read_yaml(config_file),
      flat_file_path = "dev/flat_test.Rmd",
      state = "active",
      # Allows to test in interactive session
      clean = "ask",
      inflate_parameters = list(
        flat_file = "dev/flat_test.Rmd",
        vignette_name = "My new vignette",
        open_vignette = FALSE,
        check = FALSE,
        document = TRUE,
        overwrite = "yes",
        clean = TRUE
      )
    )

    do_it <- readline("Test: Were you just asked to remove listed files? (y/n)") == "y"
    expect_true(do_it)

    test_that("update_one_group_yaml clean old files after interactive", {
      expect_true(file.exists("R/to_add.R"))
      expect_false(file.exists("R/to_remove.R"))
      expect_true(file.exists("tests/testthat/test-zaza.R"))
    })
  }
})


# Test df_to_config with custom config file path ----
config_file_path <- tempfile(fileext = ".yaml")

test_that("df_to_config fails when appropriate", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    all_files <- tibble::tribble(
      ~type,
      ~files,
      "R",
      "zaza.R",
      "R",
      "zozo.R",
      "test",
      "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files),
      "df_files should contains two columns named: 'type' and 'path'"
    )

    all_files <- tibble::tribble(
      ~type,
      ~path,
      "R",
      "zaza.R",
      "R",
      "zozo.R",
      "test",
      "test-zaza.R"
    )

    expect_error(
      df_to_config(all_files),
      "Some 'path' in df_files do not exist: row 1- R: zaza.R, row 2- R: zozo.R, row 3- test: test-zaza.R"
    )


    expect_no_error(
      config_file_out <- df_to_config(all_files, force = TRUE)
    )

    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(names(all_keep$keep), c("path", "state", "R", "tests", "vignettes"))
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$state, c("active"))
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, list())
  })
})
file.remove(config_file_path)

# Create files, even empty
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R", "toto.Rmd")))
config_file_path <- tempfile(fileext = ".yaml")

test_that("df_to_config works", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      # Use full path

      all_files <- tibble::tribble(
        ~type,
        ~path,
        "R",
        "zaza.R",
        "R",
        "zozo.R",
        "test",
        "test-zaza.R"
      )

      expect_message(
        config_file_out <- df_to_config(all_files),
        regexp = "R: zaza.R was added to the config file"
      )
    })

    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(
      names(all_keep$keep),
      c("path", "state", "R", "tests", "vignettes")
    )
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$state, c("active"))
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, list())
  })
})

# Second pass
all_files <- tibble::tribble(
  ~type,
  ~path,
  "r",
  "tata.R",
  "R",
  "toto.R",
  "tests",
  "test-tata.R",
  "vignettes",
  "tata_vignette.Rmd"
)

file.create(file.path(
  dir_tmp,
  c("tata.R", "toto.R", "test-tata.R", "tata_vignette.Rmd")
))


test_that("df_to_config works after 2nd run", {
  withr::with_dir(dir_tmp, {
    withr::with_options(list(fusen.config_file = config_file_path), {
      expect_message(
        config_file <- df_to_config(all_files),
        regexp = "Some files group already existed and were modified: keep"
      ) # "keep" is default
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)

# Create files, even empty ----
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R")))
dir.create(file.path(dir_tmp, "vignettes"))
file.create(file.path(dir_tmp, "vignettes", "my-vignette.Rmd"))
config_file_path <- tempfile(fileext = ".yaml")

test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {
      # Use relative path
      all_files <- tibble::tribble(
        ~type,
        ~path,
        "R",
        "zaza.R",
        "R",
        "zozo.R",
        "test",
        "test-zaza.R",
        "vignette",
        file.path("vignettes", "my-vignette.Rmd")
      )

      expect_message(
        config_file_out <- df_to_config(all_files),
        regexp =
          "vignettes: vignettes/my-vignette.Rmd was added to the config file"
      )
    })

    expect_equal(config_file_out, config_file_path)
    all_keep <- yaml::read_yaml(config_file_out)
    expect_equal(names(all_keep), "keep")
    expect_equal(
      names(all_keep$keep),
      c("path", "state", "R", "tests", "vignettes")
    )
    expect_equal(all_keep$keep$path, c("keep"))
    expect_equal(all_keep$keep$state, c("active"))
    # Relative path
    expect_equal(all_keep$keep$R, c("zaza.R", "zozo.R"))
    expect_equal(all_keep$keep$tests, c("test-zaza.R"))
    expect_equal(all_keep$keep$vignettes, c("vignettes/my-vignette.Rmd"))
  })
})

# Remove one file to see if it is detected ----
file.remove(file.path(dir_tmp, c("zaza.R")))
test_that("df_to_config works with files having no content", {
  withr::with_options(list(fusen.config_file = config_file_path), {
    withr::with_dir(dir_tmp, {
      # Use relative path
      all_files <- tibble::tribble(
        ~type,
        ~path,
        "R",
        "zaza.R",
        "R",
        "zozo.R",
        "test",
        "test-zaza.R",
        "vignette",
        file.path("vignettes", "my-vignette.Rmd")
      )

      expect_error(
        config_file_out <- df_to_config(all_files),
        regexp = "zaza.R"
      )
    })
  })
})

unlink(dir_tmp, recursive = TRUE)
file.remove(config_file_path)

# Test df_to_config with inflate parameters and flat_file_path = "keep"
config_file_path <- tempfile(fileext = ".yaml")
dir_tmp <- tempfile()
dir.create(dir_tmp)
file.create(file.path(dir_tmp, c("zaza.R", "zozo.R", "test-zaza.R")))

test_that(
  "df_to_config fails with inflate_parameters and flat_file_path = \"keep\"",
  {
    withr::with_dir(dir_tmp, {
      withr::with_options(list(fusen.config_file = config_file_path), {
        all_files <- tibble::tribble(
          ~type,
          ~path,
          "R",
          "zaza.R",
          "R",
          "zozo.R",
          "test",
          "test-zaza.R"
        )

        expect_error(
          df_to_config(
            all_files,
            inflate_parameters = list(
              flat_file = "dev/my_flat.Rmd",
              vignette_name = "My new vignette",
              open_vignette = FALSE,
              check = FALSE,
              document = TRUE,
              overwrite = "yes",
              clean = "ask"
            )
          )
        )
      })
    })
  }
)

unlink(dir_tmp, recursive = TRUE)

# df to config with inflate_parameters
dummypackage <- tempfile("dftoconfig")
dir.create(dummypackage)
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(add_minimal_package(
  pkg = dummypackage,
  overwrite = TRUE,
  open = FALSE
))
# let's create a flat file
flat_file <- dev_file[grepl("flat_", dev_file)]

dir.create(file.path(dummypackage, "R"))
file.create(file.path(dummypackage, "R", "my_fun.R"))

dir.create(file.path(dummypackage, "tests"))
dir.create(file.path(dummypackage, "tests/testthat"))
file.create(file.path(dummypackage, "tests/testthat", "test-my_fun.R"))

dir.create(file.path(dummypackage, "vignettes"))
file.create(file.path(dummypackage, "vignettes", "minimal.Rmd"))


usethis::with_project(dummypackage, {
  all_files <- structure(
    list(
      type = c("R", "test", "vignette"),
      path = c(
        file.path(dummypackage, "R", "my_fun.R"),
        file.path(dummypackage, "tests/testthat", "test-my_fun.R"),
        "vignettes/minimal.Rmd"
      )
    ),
    row.names = c(NA, -3L),
    class = c("tbl_df", "tbl", "data.frame")
  )

  relative_flat_file <- "dev/flat_minimal.Rmd"

  config_file <- df_to_config(
    df_files = all_files,
    flat_file_path = relative_flat_file,
    clean = TRUE,
    state = "active",
    force = TRUE,
    inflate_parameters = list(
      flat_file = "dev/flat_minimal.Rmd",
      vignette_name = "My new vignette",
      open_vignette = FALSE,
      check = FALSE,
      document = TRUE,
      overwrite = "yes",
      clean = "ask"
    )
  )

  config_file_content <- yaml::read_yaml(config_file)

  test_that("df_to_config works with inflate parameters", {
    expect_equal(
      config_file_content[[basename(flat_file)]][["inflate"]],
      list(
        flat_file = "dev/flat_minimal.Rmd",
        vignette_name = "My new vignette",
        open_vignette = FALSE,
        check = FALSE,
        document = TRUE,
        overwrite = "yes",
        clean = "ask"
      )
    )
  })

  # df_to_config with inflate_parameters, but with update_params=FALSE
  # so that inflate parameters are not updated but kept as is
  # Add new files
  file.create(file.path(dummypackage, "R", "my_fun2.R"))
  file.create(file.path(dummypackage, "tests/testthat", "test-my_fun2.R"))
  file.rename(
    file.path(dummypackage, "vignettes", "minimal.Rmd"),
    file.path(dummypackage, "vignettes", "minimal2.Rmd")
  )

  all_files <- structure(
    list(
      type = c("R", "R", "test", "test", "vignette"),
      path = c(
        file.path(dummypackage, "R", "my_fun.R"),
        file.path(dummypackage, "R", "my_fun2.R"),
        file.path(dummypackage, "tests/testthat", "test-my_fun.R"),
        file.path(dummypackage, "tests/testthat", "test-my_fun2.R"),
        "vignettes/minimal2.Rmd"
      )
    ),
    row.names = c(NA, -5L),
    class = c("tbl_df", "tbl", "data.frame")
  )

  config_file <- df_to_config(
    df_files = all_files,
    flat_file_path = relative_flat_file,
    clean = TRUE,
    state = "active",
    force = TRUE,
    inflate_parameters = list(
      flat_file = "dev/flat_minimal2.Rmd",
      vignette_name = "My other vignette",
      open_vignette = FALSE,
      check = TRUE,
      document = FALSE,
      overwrite = "yes",
      clean = TRUE
    ),
    update_params = FALSE
  )

  test_that("df_to_config changed all but inflate params, except names", {
    config_file_content <- yaml::read_yaml(config_file)
    expect_equal(
      config_file_content[[basename(flat_file)]][["inflate"]],
      list(
        flat_file = "dev/flat_minimal2.Rmd",
        vignette_name = "My other vignette",
        open_vignette = FALSE,
        check = FALSE,
        document = TRUE,
        overwrite = "yes",
        clean = "ask"
      )
    )
    expect_equal(
      config_file_content[[basename(flat_file)]][["R"]],
      c("R/my_fun.R", "R/my_fun2.R")
    )
    expect_equal(
      config_file_content[[basename(flat_file)]][["tests"]],
      c(
        "tests/testthat/test-my_fun.R",
        "tests/testthat/test-my_fun2.R"
      )
    )
    expect_equal(
      config_file_content[[basename(flat_file)]][["vignettes"]],
      c("vignettes/minimal2.Rmd")
    )
  })
})
unlink(dummypackage, recursive = TRUE)




# Verify df_to_config was run during ìnflate()
dummypackage <- tempfile("clean")
dir.create(dummypackage)

# {fusen} steps
fill_description(pkg = dummypackage, fields = list(Title = "Dummy Package"))
dev_file <- suppressMessages(
  add_flat_template(pkg = dummypackage, overwrite = TRUE, open = FALSE)
)
flat_file <- dev_file[grepl("flat_", dev_file)]

test_that("inflate parameters are put into config_fusen.yaml", {
  # Inflate once
  usethis::with_project(dummypackage, {
    suppressMessages(
      inflate(
        pkg = dummypackage,
        flat_file = flat_file,
        vignette_name = "Get started",
        check = FALSE,
        open_vignette = FALSE,
        extra_param = "toto"
      )
    )

    config_yml <- yaml::read_yaml(
      file.path(dummypackage, "dev/config_fusen.yaml")
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["vignette_name"]],
      "Get started"
    )

    expect_false(
      config_yml[[basename(flat_file)]][["inflate"]][["check"]]
    )

    expect_false(
      config_yml[[basename(flat_file)]][["inflate"]][["open_vignette"]]
    )

    expect_true(
      config_yml[[basename(flat_file)]][["inflate"]][["document"]]
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["overwrite"]],
      "ask"
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["clean"]],
      "ask"
    )


    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["extra_param"]],
      "toto"
    )

    # Let's inflate a second time with different parameters
    suppressMessages(
      inflate(
        pkg = dummypackage,
        flat_file = flat_file,
        vignette_name = "Get started again",
        clean = TRUE, # clean previous vignette
        check = FALSE,
        open_vignette = FALSE,
        overwrite = "yes",
        extra_param = "tutu",
        document = FALSE
      )
    )

    config_yml <- yaml::read_yaml(
      file.path(dummypackage, "dev/config_fusen.yaml")
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["vignette_name"]],
      "Get started again"
    )
    # Previous vignette deleted
    expect_true(
      file.exists(file.path("vignettes", "get-started-again.Rmd"))
    )
    expect_false(
      file.exists(file.path("vignettes", "get-started.Rmd"))
    )


    expect_false(
      config_yml[[basename(flat_file)]][["inflate"]][["check"]]
    )

    expect_false(
      config_yml[[basename(flat_file)]][["inflate"]][["open_vignette"]]
    )

    expect_false(
      config_yml[[basename(flat_file)]][["inflate"]][["document"]]
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["overwrite"]],
      "yes"
    )

    expect_true(
      config_yml[[basename(flat_file)]][["inflate"]][["clean"]]
    )

    expect_equal(
      config_yml[[basename(flat_file)]][["inflate"]][["extra_param"]],
      "tutu"
    )
  })
})

unlink(dummypackage, recursive = TRUE)
# rstudioapi::navigateToFile(config_file)
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_register_config_file.Rmd",
  vignette_name = "Register files in config",
  check = FALSE,
  overwrite = TRUE,
  open_vignette = FALSE
)
# rstudioapi::navigateToFile("dev/dev_history.R", line = 105)
```
